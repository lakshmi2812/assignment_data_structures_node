# assignment_data_structures_node

<<<<<<< HEAD

1. Accessing an item by index in an array

* o(1)

2. Unshifting a new item into the beginning of an array

* o(1)

3. Pushing an item onto the end of an array

* o(1)

Upcasing a String

* o(n)

Reversing a String

* o(n)

Finding the max of an array

* o(n)

splitting a String

* o(n)

Inserting a value to an Object

* o(1)

Retrieving the keys of an Object ({ foo: "bar" }.keys)

* # o(n)
  # #Big-O Warmup Answers

1. O(1) --> constant time operation
2. O(n) --> because we have to shift every element in the array one position to
   the right. So, for an array of length size n, it is n times 0(1), which is
   O(n).
3. O(1) --> constant-time operation.
4. O(n) --> go through each element and convert to upper case.
5. O(n) --> linear time
6. 0(nlogn) --> because, best sorting algorithm we know(merge sort) takes
   O(nlogn) run-time.
7. O(n) --> because we need to look at every character in the string, and when
   we split we only have to look in the most recent split string, not any of the
   others.
8. O(1) --> No order, no traversing, just make a new element at a certain
   address in memory.
9. O(n) --> because obviously

* # HashTable Big-O

1. insert an element --> O(n), where n is the position in the linked list where
   it needs to be inserted
2. lookup an element --> O(n), depends on where in the linked list, the word is
   located
3.
